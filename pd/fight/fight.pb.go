// Code generated by protoc-gen-go. DO NOT EDIT.
// source: fight.proto

package fight

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Hero_Gender int32

const (
	Hero_MALE   Hero_Gender = 0
	Hero_FEMALE Hero_Gender = 1
)

var Hero_Gender_name = map[int32]string{
	0: "MALE",
	1: "FEMALE",
}

var Hero_Gender_value = map[string]int32{
	"MALE":   0,
	"FEMALE": 1,
}

func (x Hero_Gender) String() string {
	return proto.EnumName(Hero_Gender_name, int32(x))
}

func (Hero_Gender) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0a9b36907fd4a279, []int{1, 0}
}

type ListHerosRequest struct {
	// support: specify hero names
	Names                []string `protobuf:"bytes,1,rep,name=names,proto3" json:"names,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListHerosRequest) Reset()         { *m = ListHerosRequest{} }
func (m *ListHerosRequest) String() string { return proto.CompactTextString(m) }
func (*ListHerosRequest) ProtoMessage()    {}
func (*ListHerosRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9b36907fd4a279, []int{0}
}

func (m *ListHerosRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListHerosRequest.Unmarshal(m, b)
}
func (m *ListHerosRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListHerosRequest.Marshal(b, m, deterministic)
}
func (m *ListHerosRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListHerosRequest.Merge(m, src)
}
func (m *ListHerosRequest) XXX_Size() int {
	return xxx_messageInfo_ListHerosRequest.Size(m)
}
func (m *ListHerosRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListHerosRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListHerosRequest proto.InternalMessageInfo

func (m *ListHerosRequest) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type Hero struct {
	Name                 string      `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Age                  uint32      `protobuf:"varint,2,opt,name=age,proto3" json:"age,omitempty"`
	Gender               Hero_Gender `protobuf:"varint,3,opt,name=gender,proto3,enum=fight.Hero_Gender" json:"gender,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Hero) Reset()         { *m = Hero{} }
func (m *Hero) String() string { return proto.CompactTextString(m) }
func (*Hero) ProtoMessage()    {}
func (*Hero) Descriptor() ([]byte, []int) {
	return fileDescriptor_0a9b36907fd4a279, []int{1}
}

func (m *Hero) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Hero.Unmarshal(m, b)
}
func (m *Hero) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Hero.Marshal(b, m, deterministic)
}
func (m *Hero) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hero.Merge(m, src)
}
func (m *Hero) XXX_Size() int {
	return xxx_messageInfo_Hero.Size(m)
}
func (m *Hero) XXX_DiscardUnknown() {
	xxx_messageInfo_Hero.DiscardUnknown(m)
}

var xxx_messageInfo_Hero proto.InternalMessageInfo

func (m *Hero) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Hero) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *Hero) GetGender() Hero_Gender {
	if m != nil {
		return m.Gender
	}
	return Hero_MALE
}

func init() {
	proto.RegisterEnum("fight.Hero_Gender", Hero_Gender_name, Hero_Gender_value)
	proto.RegisterType((*ListHerosRequest)(nil), "fight.ListHerosRequest")
	proto.RegisterType((*Hero)(nil), "fight.Hero")
}

func init() { proto.RegisterFile("fight.proto", fileDescriptor_0a9b36907fd4a279) }

var fileDescriptor_0a9b36907fd4a279 = []byte{
	// 209 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0x4e, 0xcb, 0x4c, 0xcf,
	0x28, 0xd1, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0x05, 0x73, 0x94, 0x34, 0xb8, 0x04, 0x7c,
	0x32, 0x8b, 0x4b, 0x3c, 0x52, 0x8b, 0xf2, 0x8b, 0x83, 0x52, 0x0b, 0x4b, 0x53, 0x8b, 0x4b, 0x84,
	0x44, 0xb8, 0x58, 0xf3, 0x12, 0x73, 0x53, 0x8b, 0x25, 0x18, 0x15, 0x98, 0x35, 0x38, 0x83, 0x20,
	0x1c, 0xa5, 0x0a, 0x2e, 0x16, 0x90, 0x2a, 0x21, 0x21, 0x2e, 0x16, 0x90, 0x80, 0x04, 0xa3, 0x02,
	0xa3, 0x06, 0x67, 0x10, 0x98, 0x2d, 0x24, 0xc0, 0xc5, 0x9c, 0x98, 0x9e, 0x2a, 0xc1, 0xa4, 0xc0,
	0xa8, 0xc1, 0x1b, 0x04, 0x62, 0x0a, 0x69, 0x71, 0xb1, 0xa5, 0xa7, 0xe6, 0xa5, 0xa4, 0x16, 0x49,
	0x30, 0x2b, 0x30, 0x6a, 0xf0, 0x19, 0x09, 0xe9, 0x41, 0x2c, 0x07, 0x19, 0xa1, 0xe7, 0x0e, 0x96,
	0x09, 0x82, 0xaa, 0x50, 0x92, 0xe3, 0x62, 0x83, 0x88, 0x08, 0x71, 0x70, 0xb1, 0xf8, 0x3a, 0xfa,
	0xb8, 0x0a, 0x30, 0x08, 0x71, 0x71, 0xb1, 0xb9, 0xb9, 0x82, 0xd9, 0x8c, 0x46, 0x36, 0x5c, 0xac,
	0x6e, 0x20, 0xcd, 0x42, 0xc6, 0x5c, 0x9c, 0x70, 0xc7, 0x0a, 0x89, 0x43, 0x4d, 0x44, 0x77, 0xbe,
	0x14, 0x37, 0x92, 0x55, 0x06, 0x8c, 0x4e, 0x9c, 0x51, 0xec, 0x7a, 0xd6, 0x60, 0x91, 0x24, 0x36,
	0xb0, 0xd7, 0x8d, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0x59, 0x70, 0xe7, 0xb6, 0x09, 0x01, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// FightClient is the client API for Fight service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type FightClient interface {
	ListHeros(ctx context.Context, in *ListHerosRequest, opts ...grpc.CallOption) (Fight_ListHerosClient, error)
}

type fightClient struct {
	cc *grpc.ClientConn
}

func NewFightClient(cc *grpc.ClientConn) FightClient {
	return &fightClient{cc}
}

func (c *fightClient) ListHeros(ctx context.Context, in *ListHerosRequest, opts ...grpc.CallOption) (Fight_ListHerosClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Fight_serviceDesc.Streams[0], "/fight.Fight/ListHeros", opts...)
	if err != nil {
		return nil, err
	}
	x := &fightListHerosClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Fight_ListHerosClient interface {
	Recv() (*Hero, error)
	grpc.ClientStream
}

type fightListHerosClient struct {
	grpc.ClientStream
}

func (x *fightListHerosClient) Recv() (*Hero, error) {
	m := new(Hero)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// FightServer is the server API for Fight service.
type FightServer interface {
	ListHeros(*ListHerosRequest, Fight_ListHerosServer) error
}

// UnimplementedFightServer can be embedded to have forward compatible implementations.
type UnimplementedFightServer struct {
}

func (*UnimplementedFightServer) ListHeros(req *ListHerosRequest, srv Fight_ListHerosServer) error {
	return status.Errorf(codes.Unimplemented, "method ListHeros not implemented")
}

func RegisterFightServer(s *grpc.Server, srv FightServer) {
	s.RegisterService(&_Fight_serviceDesc, srv)
}

func _Fight_ListHeros_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListHerosRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FightServer).ListHeros(m, &fightListHerosServer{stream})
}

type Fight_ListHerosServer interface {
	Send(*Hero) error
	grpc.ServerStream
}

type fightListHerosServer struct {
	grpc.ServerStream
}

func (x *fightListHerosServer) Send(m *Hero) error {
	return x.ServerStream.SendMsg(m)
}

var _Fight_serviceDesc = grpc.ServiceDesc{
	ServiceName: "fight.Fight",
	HandlerType: (*FightServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListHeros",
			Handler:       _Fight_ListHeros_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "fight.proto",
}
